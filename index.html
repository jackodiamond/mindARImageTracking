<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.1.5/dist/mindar-image-three.prod.js"></script>
    <title>MindAR Image Tracking</title>

    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.147.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.147.0/examples/jsm/"
    
  }
}
</script>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
    <script type="module">

      import * as THRE from 'three';

      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

      import { FontLoader } from 'three/addons/loaders/FontLoader.js';
      
      import {TextGeometry} from 'three/addons/geometries/TextGeometry.js';

      var sceneIndex = 1;
      const THREE = window.MINDAR.IMAGE.THREE;
      const mindarThree = new window.MINDAR.IMAGE.MindARThree({
    container: document.querySelector("#container"),
    imageTargetSrc: "targets.mind"
      });
      const {renderer, scene, camera} = mindarThree;
      const anchor = [];
      const anchor1 = mindarThree.addAnchor(0);
      anchor.push(anchor1);
      const anchor2 = mindarThree.addAnchor(1);
      anchor.push(anchor2);
      const geometry = new THREE.PlaneGeometry(1, 0.55);
      const material = new THREE.MeshBasicMaterial( {color: 0x00ffff, transparent: true, opacity: 0.9} );
      const plane = new THREE.Mesh( geometry, material );
      var mesh;
      var recievedObject;
      var recievedObjectCopy=[];
      var objects=[];
      var gltfScene= [];
      var gltfIndex =0;
      var currentScene;
      var mixer;
      var video,audio;
      var clock = new THREE.Clock();
      var videos = new Map();
      var audios = new Map();
   //   anchor.group.add(plane);
      const start = async() => {
    await mindarThree.start();
    renderer.setAnimationLoop(() => {
    var delta = clock.getDelta();
        if ( mixer ) mixer.update( delta );

      renderer.render(scene, camera);
    });
      }

  start();
      
      const startButton = document.querySelector("#startButton");
      startButton.addEventListener("click", () => {
    start();
      });
      stopButton.addEventListener("click", () => {
    mindarThree.stop();
    mindarThree.renderer.setAnimationLoop(null);
      });
      
      
      
      
      
const ObjectType ={
    cube:0,
    sphere:1,
    cylinder:2,
    text:3,
    image:4,
    gltf:5,
    video:6,
    capsule:7,
    polyhedron:8,
    glodberg:9,
    icosphere:10,
    torus:11,
    torusknot:12,
    audio:13,
    button:14
}

const actionType ={
    click:0,
    drag:1
}

class baseObject{

    constructor(name, textValue,type,action,actionObject,objectPosition,objectRotation,objectScale) {
    this.baseObjectName = name;
    this.textValue = textValue;
    this.objectType = type;
    this.action = action;
    this.actionObject = actionObject;
    this.position = objectPosition;
    this.rotation = objectRotation;
    this.scale = objectScale;
  }

    baseObjectName;
    textValue;
    objectType; 
    action;
    actionObject;
    position;
    rotation;
    scale;
}


class SceneObject {
  id;
  name;
  meshObjects=[];
}


class MeshObject{
  id;
  name;
  sceneId;
  mesh;
  meshType;
  position;
  rotation;
  scale;
  // value: string
  // gltkUrl?: string
  actions;
}



loadFile();

function readTextFile(file, callback) {
    var rawFile = new XMLHttpRequest();
    rawFile.overrideMimeType("application/json");
    rawFile.open("GET", file, true);
    rawFile.onreadystatechange = function() {
        if (rawFile.readyState === 4 && rawFile.status == "200") {
            callback(rawFile.responseText);
        }
    }
    rawFile.send(null);
}



function loadFile()
{
    console.log("abc");
    var cubePos = new THREE.Vector3 (10,1,0);
    var cubeRot = new THREE.Vector3 (90,0,0);
    var cubeScale = new THREE.Vector3(1,1,1);

    var cubeObject = new baseObject("cube01",null,ObjectType.Cube,actionType.click,cubePos,cubeRot,cubeScale);

    var imagePos = new THREE.Vector3    (-10,1,0);
    var imageRot = new THREE.Vector3    (90,90,0);
    var imageScale = new THREE.Vector3(5,3,1);

    readTextFile("data.json", function(text) {
      console.log("text : "+text);
   recievedObject = JSON.parse(text);
    console.log("len "+recievedObject.length);
    
    
    console.log("?");
  for(var i=0;i<recievedObject.length;i++)
    {
      console.log("sceneIndex -1 :"+sceneIndex-1);
      
      console.log("i: "+i);
      
      if(sceneIndex-1 != i)
      {
        console.log("break : "+i);
        continue;
      }
      
      if(recievedObject[i].sceneType != 1)
      {
        console.log("scene type is not image tracking!");
        continue;
      }


      currentScene=0;
      console.log("::cs : "+currentScene)
      recievedObjectCopy.push(recievedObject[i]);


      var objects = recievedObject[i].meshObjects;

    
      for(j=0;j<objects.length;j++)
      {
        console.log("yo : "+objects[j].meshType);
      }

        for(var j=0;j<objects.length;j++)
        {
            console.log("2 "+objects[j].meshType);
            switch(objects[j].meshType)
            {
                    case "cube":
                        console.log("boax");
                    loadBox(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
                    break;
                    
                    case "sphere":
                        console.log("sphere");
                    loadSphere(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
                    break;

          case "cylinder":
              console.log("cylinder");
          loadCylinder(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break;
          
          case "capsule":
              console.log("capsule");
              gltfScene.push(currentScene);
          loadCapsule(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break;

          case "polyhedron":
              console.log("polyhedron");
          loadPolyhedron(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break;
          
          case "goldberg":
              console.log("goldberg");
          loadGoldberg(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break

          case "icosphere":
              console.log("icosphere");
          loadIcosphere(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break;
          
          case "torus":
              console.log("torus");
          loadTorus(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break;

          case "torusknot":
              console.log("torusknot");
          loadTorusknot(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break;

                    case "image":
                        console.log("image");
                    loadImage(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z,objects[j].mediaUrl);
                    break;

                    case "video":
                        console.log("video");
                    loadVideo(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z,objects[j].mediaUrl);
                    break;

          case "audio":
              console.log("audio");
          loadAudio(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z,objects[j].mediaUrl);
          break;

          case "text":
              console.log("txt");
          loadText(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z,objects[j].mediaUrl,objects[j].label);
          break;

          case "button":
              console.log("btn");
          loadButton(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z,objects[j].mediaUrl);
          break;

          case "gltf":
              console.log("gltf scene to add "+currentScene);
              gltfScene.push(currentScene);
          loadGLTF(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z,objects[j].mediaUrl);
          break;
            }
        }
    }

});

    const light = new THREE.PointLight(0xffffff, 1.2);
    light.position.set(1.1, 1.1, 1);
    anchor[0].group.add(light);
    const light2 = new THREE.PointLight(0xffffff, 1.2);
    light2.position.set(1.1, 1.1, 1);
    anchor[1].group.add(light2);
}

function loadBox(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  console.log("box scene "+currentScene);
    const geometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
//  const geometry2 = new THREE.sp
    const material = new THREE.MeshLambertMaterial( { color: 0xc0c0c0 } );
    var mesh = new THREE.Mesh( geometry, material );

    anchor[currentScene].group.add(mesh);
    mesh.position.set(posx*0.1,posz*0.1,posy*0.1);
    mesh.rotation.set(rotx,roty,rotz);
    mesh.scale.set(scalex,scaley,scalez);
    objects.push(mesh);
}

function loadSphere(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
    const geometry = new THREE.SphereGeometry( 0.15, 32, 16 );
    const material = new THREE.MeshBasicMaterial( { color: 0xc0c0c0 } );
    var sphere = new THREE.Mesh( geometry, material );
  anchor[currentScene].group.add(sphere);
  sphere.position.set(posx*0.1,posz*0.1,posy*0.1);
       sphere.rotation.set(rotx,roty,rotz);
    sphere.scale.set(scalex,scaley,scalez);
  objects.push(sphere);
}

function loadCylinder(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  const geometry = new THREE.CylinderGeometry( 0.2, 0.2, 0.5,10 );
  //  const geometry2 = new THREE.sp
  const material = new THREE.MeshLambertMaterial( { color: 0xc0c0c0 } );
  var mesh = new THREE.Mesh( geometry, material );
  console.log("cylinder scene"+currentScene);
  anchor[currentScene].group.add(mesh);
  mesh.position.set(posx*0.1,posz*0.1,posy*0.1);
      mesh.rotation.set(rotx,roty,rotz);
    mesh.scale.set(scalex,scaley,scalez);
  objects.push(mesh);
}

function loadCapsule(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  console.log("capsule scene "+currentScene);
  // Instantiate a loader
const loader = new GLTFLoader();


// Load a glTF resource
loader.load(
  // resource URL
  'models/capsule.glb',
  // called when the resource is loaded
  function ( gltf ) {

    
    //scene.add( gltf.scene );
    console.log("capsule scene "+gltfScene[gltfIndex]);
    anchor[gltfScene[gltfIndex]].group.add(gltf.scene);
    gltfIndex++;
    mesh= gltf.scene;
    gltf.scene.position.set(posx*0.1,posy*0.1,posz*0.1);
    gltf.scene.rotation.set(rotx,roty,rotz);
    gltf.scene.scale.set(scalex*0.1,scaley*0.1,scalez*0.1);

    gltf.animations; // Array<THREE.AnimationClip>
    gltf.scene; // THREE.Group
    gltf.scenes; // Array<THREE.Group>
    gltf.cameras; // Array<THREE.Camera>
    gltf.asset; // Object

      mixer = new THREE.AnimationMixer( gltf.scene );
        
        gltf.animations.forEach( ( clip ) => {
          
            mixer.clipAction( clip ).play();
          
        } );
    

  },
  // called while loading is progressing
  function ( xhr ) {

    console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

  },
  // called when loading has errors
  function ( error ) {

    console.log( 'An error happened' );

  }
  );
}

function loadPolyhedron(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  const geometry = new THREE.TetrahedronGeometry(0.2,0);
  const material = new THREE.MeshBasicMaterial( { color: 0xc0c0c0 } );
  var sphere = new THREE.Mesh( geometry, material );
  anchor[currentScene].group.add(sphere);
  sphere.position.set(posx*0.1,posz*0.1,posy*0.1);
      sphere.rotation.set(rotx,roty,rotz);
    sphere.scale.set(scalex,scaley,scalez);
  objects.push(sphere);
}

function loadGoldberg(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  const geometry = new THREE.DodecahedronGeometry(0.4,0);
  const material = new THREE.MeshBasicMaterial( { color: 0xc0c0c0 } );
  var sphere = new THREE.Mesh( geometry, material );
  anchor[currentScene].group.add(sphere);
  sphere.position.set(posx*0.1,posz*0.1,posy*0.1);
      sphere.rotation.set(rotx,roty,rotz);
    sphere.scale.set(scalex,scaley,scalez);
  objects.push(sphere);
}

function loadIcosphere(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  const geometry = new THREE.IcosahedronGeometry(0.2,0);
  const material = new THREE.MeshBasicMaterial( { color: 0xc0c0c0 } );
  var sphere = new THREE.Mesh( geometry, material );
  anchor[currentScene].group.add(sphere);
  sphere.position.set(posx*0.1,posz*0.1,posy*0.1);
        sphere.rotation.set(rotx,roty,rotz);
    sphere.scale.set(scalex,scaley,scalez);
  objects.push(sphere);
}

function loadTorus(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  const geometry = new THREE.TorusGeometry(0.2,0.02,10,10);
  const material = new THREE.MeshBasicMaterial( { color: 0xc0c0c0 } );
  var sphere = new THREE.Mesh( geometry, material );
  anchor[currentScene].group.add(sphere);
  sphere.position.set(posx*0.1,posz*0.1,posy*0.1);
      sphere.rotation.set(rotx,roty,rotz);
    sphere.scale.set(scalex,scaley,scalez);
  objects.push(sphere);
}

function loadTorusknot(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  const geometry = new THREE.TorusKnotGeometry(0.1,0.01,5,5);
  const material = new THREE.MeshBasicMaterial( { color: 0xc0c0c0 } );
  var sphere = new THREE.Mesh( geometry, material );
  anchor[currentScene].group.add(sphere);
  sphere.position.set(posx*0.1,posz*0.1,posy*0.1);
      sphere.rotation.set(rotx,roty,rotz);
    sphere.scale.set(scalex,scaley,scalez);
  objects.push(sphere);
}

function loadImage(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez,url)
{
    var planeGeometry = new THREE.PlaneGeometry(0.3, 0.3, 1, 1);
    var textur = new THREE.TextureLoader().load( url );
    var planeMaterial = new THREE.MeshPhysicalMaterial( { map: textur } );
    var plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.receiveShadow = true;

    console.log("plane added");
    anchor[currentScene].group.add(plane);
    plane.position.set(posx*0.001,posz*0.001,posy*0.001);
        plane.rotation.set(rotx,roty,rotz);
    plane.scale.set(scalex,scaley,scalez);
  //  objects.push(plane);
}

function loadVideo(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez,url)
{
    var planeGeometry = new THREE.PlaneGeometry(0.3, 0.3, 1, 1);

    // Create a new VideoTexture from a video file
    video = document.createElement('video');
    video.src = url;
    video.load();
    video.pause();
  //  video.play();
    var videoTexture = new THREE.VideoTexture(video);

    // Create a new MeshPhysicalMaterial with the video texture as the map
    var planeMaterial = new THREE.MeshPhysicalMaterial( { map: videoTexture } );

    // Create a new Mesh object using the PlaneGeometry and MeshPhysicalMaterial
    var plane = new THREE.Mesh(planeGeometry, planeMaterial);

    plane.receiveShadow = true;

    console.log("plane added");
    anchor[currentScene].group.add(plane);
    plane.position.set(posx*0.001,posz*0.001,posy*0.001); 
        plane.rotation.set(rotx,roty,rotz);
    plane.scale.set(scalex,scaley,scalez);
    plane.name = "video";
    objects.push(plane);
    videos.set(plane, video);
}

function loadAudio(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez,url)
{
    var planeGeometry = new THREE.PlaneGeometry(0.1, 0.1, 1, 1);
    var textur = new THREE.TextureLoader().load( 'textures/audio.png' );
    var planeMaterial = new THREE.MeshPhysicalMaterial( { map: textur } );
    var plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.receiveShadow = true;

    audio = new Audio(url);

    console.log("plane added");
    anchor[currentScene].group.add(plane);
    plane.position.set(posx*0.001,posz*0.001,posy*0.001);
            plane.rotation.set(rotx,roty,rotz);
    plane.scale.set(scalex,scaley,scalez);
    plane.name = "audio";
    objects.push(plane);
    audios.set(plane, audio);
}

function loadText(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez,label)
{

  // Instantiate a loader
  const fontLoader = new FontLoader();
   
   
   let font = fontLoader.parse('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json');
    var textGeo = new TextGeometry('three.js', {
      font: font,
      size: 120,
      height: 1,
      material: 0,
      bevelThickness: 1,
      extrudeMaterial: 1
    });

  // Create text material
  const textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000 } );

  // Create text mesh
  var textMesh = new THREE.Mesh(textGeo, textMaterial);
  textMesh.position.set(posx*0.1,posz*0.1,posy*0.1);
  textMesh.rotation.set(rotx,roty,rotz);
  textMesh.scale.set(scalex,scaley,scalez);
  scene.add(textMesh);
  console.log("text added");
  
}

function loadButton(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
    //button same as cube
    const geometry = new THREE.BoxGeometry( 0.1, 0.05, 0.01 );
//  const geometry2 = new THREE.sp
    const material = new THREE.MeshLambertMaterial( { color: 0xc0c0c0 } );
    var mesh = new THREE.Mesh( geometry, material );

    anchor[currentScene].group.add(mesh);
    mesh.position.set(posx*0.1,posz*0.1,posy*0.1);
    mesh.rotation.set(rotx,roty,rotz);
    mesh.scale.set(scalex,scaley,scalez);
    objects.push(mesh);
}


function loadGLTF(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez,url)
{
  
    // Instantiate a loader
const loader = new GLTFLoader();


// Load a glTF resource
loader.load(
    // resource URL
    url,
    // called when the resource is loaded
    function ( gltf ) {

    
        //scene.add( gltf.scene );
    console.log("gltf scene"+gltfScene[gltfIndex]);
        anchor[gltfScene[gltfIndex]].group.add(gltf.scene);
        mesh= gltf.scene;
        gltf.scene.position.set(posx*0.1,posy*0.1,posz*0.1);
        gltf.scene.rotation.set(rotx,roty,rotz);
        gltf.scene.scale.set(scalex*0.1,scaley*0.1,scalez*0.1);

        gltf.animations; // Array<THREE.AnimationClip>
        gltf.scene; // THREE.Group
        gltf.scenes; // Array<THREE.Group>
        gltf.cameras; // Array<THREE.Camera>
        gltf.asset; // Object

      mixer = new THREE.AnimationMixer( gltf.scene );
        
        gltf.animations.forEach( ( clip ) => {
          
            mixer.clipAction( clip ).play();
          
        } );
    

    },
    // called while loading is progressing
    function ( xhr ) {

        console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

    },
    // called when loading has errors
    function ( error ) {

        console.log( 'An error happened' );

    }
    );
  }
        document.addEventListener( 'mousedown', onDocumentMouseDown );

            function onDocumentMouseDown( event ) {
                
            console.log("mouse down event");
            
            event.preventDefault();
            
            var mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
                                    0.5 );     
                                    
            var raycaster =  new THREE.Raycaster();    
            
                  raycaster.setFromCamera( mouse3D, camera );

            var intersects = raycaster.intersectObjects( scene.children ); 

            if ( intersects.length > 0 ) {

                console.log(" intersect len : "+intersects.length);
                
                console.log(" objects len : "+objects.length);
                
                for(var i=0;i<objects.length;i++)
                {  
                        if(intersects[0].object==objects[i])
                        {
                            console.log("object found "+objects[i].name);
                        if(objects[i].name == "video")
                        {
                           console.log("video clicked!");
                          if (videos.get(objects[i]).paused) {
                            videos.get(objects[i]).play();
                          } else {
                            videos.get(objects[i]).pause();
                          }
                        }
                        if(objects[i].name == "audio")
                        {
                           console.log("audio clicked!");
                          if (audios.get(objects[i]).paused) {
                            audios.get(objects[i]).play();
                          } else {
                            audios.get(objects[i]).pause();
                          }
                        }
                             if(recievedObjectCopy[i].actionObject=="NONE")
                             { 
                                console.log("none ");
                                //hide the mesh, replace below line
                                objects[i].position.set(0,0,0);
                             }
                             
                             if(recievedObjectCopy[i].actionObject=="CUBE")
                             {
                                 objects[i].position.set(10,0,0);
                                 loadBox(recievedObjectCopy[i].position.x,recievedObjectCopy[i].position.y,recievedObjectCopy[i].position.z);
                             }
                             
                             if(recievedObjectCopy[i].actionObject=="SPHERE")
                             {
                                 objects[i].position.set(10,0,0);
                                 loadSphere(recievedObjectCopy[i].position.x,recievedObjectCopy[i].position.y,recievedObjectCopy[i].position.z);
                             }
                             
                             if(recievedObjectCopy[i].actionObject=="IMAGE")
                             {
                                 objects[i].position.set(10,0,0);
                                 loadImage(recievedObjectCopy[i].position.x,recievedObjectCopy[i].position.y,recievedObjectCopy[i].position.z);
                             }
                        }
                }
                
            }
             
            }

    </script>
    <style>
      body {
    margin: 0;
      }
      #container {
    width: 100vw;
    height: 100vh;
    position: relative;
    overflow: hidden;
      }
      #control {
    position: fixed;
    top: 0;
    left: 0;
    z-index: 2;
      }
    </style>
  </head>
  <body>
    <div id="control">
      <button id="startButton">Start</button>
      <button id="stopButton">Stop</button>
    </div>
    <div id="container">
    </div>
  </body>
</html>
