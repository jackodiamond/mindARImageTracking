<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.1.5/dist/mindar-image-three.prod.js"></script>
    <title>MindAR Image Tracking</title>
    
    <style>
         * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -applesystem, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu,
               Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
         }
         html,
         body {
            height: 100vh;
            width: 100vw;
         }
         #threejs-container {
            position: block;
            width: 100%;
            height: 100%;
         }
      </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.147.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.147.0/examples/jsm/"
    
  }
}
</script>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
    <script type="module">

      import * as THRE from 'three';

      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

      import { FontLoader } from 'three/addons/loaders/FontLoader.js';
      
      import {TextGeometry} from 'three/addons/geometries/TextGeometry.js';

      var sceneIndex = 1;
      const THREE = window.MINDAR.IMAGE.THREE;
      const mindarThree = new window.MINDAR.IMAGE.MindARThree({
    container: document.querySelector("#container"),
    imageTargetSrc: "targets.mind"
      });
      const {renderer, scene, camera} = mindarThree;
      const anchor = [];
      const anchor1 = mindarThree.addAnchor(0);
      anchor.push(anchor1);
      const anchor2 = mindarThree.addAnchor(1);
      anchor.push(anchor2);
      const geometry = new THREE.PlaneGeometry(1, 0.55);
      const material = new THREE.MeshBasicMaterial( {color: 0x00ffff, transparent: true, opacity: 0.9} );
      const plane = new THREE.Mesh( geometry, material );
      var mesh;
      var recievedObject;
      var recievedObjectCopy=[];
      var objects=[];
      var gltfScene= [];
      var gltfIndex =0;
      var currentScene;
      var mixer;
      var video,audio;
      var clock = new THREE.Clock();
      var videos = new Map();
      var audios = new Map();
   //   anchor.group.add(plane);
      const start = async() => {
    await mindarThree.start();
    renderer.setAnimationLoop(() => {
    var delta = clock.getDelta();
        if ( mixer ) mixer.update( delta );

      renderer.render(scene, camera);
    });
      }

  start();
      
      const startButton = document.querySelector("#startButton");
      startButton.addEventListener("click", () => {
    start();
      });
      stopButton.addEventListener("click", () => {
    mindarThree.stop();
    mindarThree.renderer.setAnimationLoop(null);
      });
      
      
      
      
      
const ObjectType ={
    cube:0,
    sphere:1,
    cylinder:2,
    text:3,
    image:4,
    gltf:5,
    video:6,
    capsule:7,
    polyhedron:8,
    glodberg:9,
    icosphere:10,
    torus:11,
    torusknot:12,
    audio:13,
    button:14,
    hotspot:15
  }

const actionType ={
    click:0,
    drag:1
}

class baseObject{

    constructor(name, textValue,type,action,actionObject,objectPosition,objectRotation,objectScale) {
    this.baseObjectName = name;
    this.textValue = textValue;
    this.objectType = type;
    this.action = action;
    this.actionObject = actionObject;
    this.position = objectPosition;
    this.rotation = objectRotation;
    this.scale = objectScale;
  }

    baseObjectName;
    textValue;
    objectType; 
    action;
    actionObject;
    position;
    rotation;
    scale;
}


class SceneObject {
  id;
  name;
  meshObjects=[];
}


class MeshObject{
  id;
  name;
  sceneId;
  mesh;
  meshType;
  position;
  rotation;
  scale;
  // value: string
  // gltkUrl?: string
  actions;
}



loadFile();

function readTextFile(file, callback) {
    var rawFile = new XMLHttpRequest();
    rawFile.overrideMimeType("application/json");
    rawFile.open("GET", file, true);
    rawFile.onreadystatechange = function() {
        if (rawFile.readyState === 4 && rawFile.status == "200") {
            callback(rawFile.responseText);
        }
    }
    rawFile.send(null);
}



function loadFile()
{
    console.log("abc");
    var cubePos = new THREE.Vector3 (10,1,0);
    var cubeRot = new THREE.Vector3 (90,0,0);
    var cubeScale = new THREE.Vector3(1,1,1);

    var cubeObject = new baseObject("cube01",null,ObjectType.Cube,actionType.click,cubePos,cubeRot,cubeScale);

    var imagePos = new THREE.Vector3    (-10,1,0);
    var imageRot = new THREE.Vector3    (90,90,0);
    var imageScale = new THREE.Vector3(5,3,1);

    readTextFile("data.json", function(text) {
      console.log("text : "+text);
   recievedObject = JSON.parse(text);
    console.log("len "+recievedObject.length);
    
    
    console.log("?");
  for(var i=0;i<recievedObject.length;i++)
    {
      console.log("sceneIndex -1 :"+sceneIndex-1);
      
      console.log("i: "+i);
      
      if(sceneIndex-1 != i)
      {
        console.log("break : "+i);
        continue;
      }
      
      if(recievedObject[i].sceneType != 1)
      {
        console.log("scene type is not image tracking!");
        continue;
      }


      currentScene=0;
      console.log("::cs : "+currentScene)
      recievedObjectCopy.push(recievedObject[i]);


      var objects = recievedObject[i].meshObjects;

    
      for(j=0;j<objects.length;j++)
      {
        console.log("yo : "+objects[j].meshType);
      }

        for(var j=0;j<objects.length;j++)
        {
            console.log("2 "+objects[j].meshType);
            switch(objects[j].meshType)
            {
                    case "cube":
                        console.log("boax");
                    loadBox(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y+1.5,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
                    break;
                    
                    case "sphere":
                        console.log("sphere");
                    loadSphere(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
                    break;

          case "cylinder":
              console.log("cylinder");
          loadCylinder(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y+1.5,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break;
          
          case "capsule":
              console.log("capsule");
              gltfScene.push(currentScene);
          loadCapsule(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y+1.5,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break;

          case "polyhedron":
              console.log("polyhedron");
          loadPolyhedron(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y+1.5,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break;
          
          case "goldberg":
              console.log("goldberg");
          loadGoldberg(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break

          case "icosphere":
              console.log("icosphere");
          loadIcosphere(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break;
          
          case "torus":
              console.log("torus");
          loadTorus(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break;

          case "torusknot":
              console.log("torusknot");
          loadTorusknot(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z);
          break;

                    case "image":
                        console.log("image");
                    loadImage(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y+1.5,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z,objects[j].mediaUrl);
                    break;

                    case "video":
                        console.log("video");
                    loadVideo(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y+1.5,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z,objects[j].mediaUrl);
                    break;

          case "audio":
              console.log("audio");
          loadAudio(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y+1.5,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z,objects[j].mediaUrl);
          break;

          case "text":
              console.log("txt :"+objects[j].label);
          loadText(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y+1.5,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z,objects[j].label);
          break;

          case "button":
              console.log("btn");
          loadButton(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y+1.5,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z,objects[j].mediaUrl);
          break;

          case "gltf":
              console.log("gltf scene to add "+currentScene);
              gltfScene.push(currentScene);
          loadGLTF(objects[j].position.x,objects[j].position.y,objects[j].position.z,objects[j].rotation.x,objects[j].rotation.y+1.5,objects[j].rotation.z,objects[j].scale.x,objects[j].scale.y,objects[j].scale.z,objects[j].mediaUrl);
          break;

          case "hotspot":
              console.log("hotspot");
              loadHotspot(objects[j]);
          break;
            }
        }
    }

});

    const light = new THREE.PointLight(0xffffff, 1.2);
    light.position.set(1.1, 1.1, 1);
    anchor[0].group.add(light);
    const light2 = new THREE.PointLight(0xffffff, 1.2);
    light2.position.set(-1.1, -1.1, 1);
    anchor[0].group.add(light2);
}

function loadBox(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  console.log("box scene "+currentScene);
    const geometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
//  const geometry2 = new THREE.sp
    const material = new THREE.MeshLambertMaterial( { color: 0xc0c0c0 } );
    var mesh = new THREE.Mesh( geometry, material );

    anchor[currentScene].group.add(mesh);
    mesh.position.set(posx*0.1,posz*0.1,posy*0.1);
    mesh.rotation.set(rotx,roty,rotz);
    mesh.scale.set(scalex,scaley,scalez);
    objects.push(mesh);
}

function loadSphere(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
    const geometry = new THREE.SphereGeometry( 0.15, 32, 16 );
    const material = new THREE.MeshBasicMaterial( { color: 0xc0c0c0 } );
    var sphere = new THREE.Mesh( geometry, material );
  anchor[currentScene].group.add(sphere);
  sphere.position.set(posx*0.1,posz*0.1,posy*0.1);
       sphere.rotation.set(rotx,roty,rotz);
    sphere.scale.set(scalex,scaley,scalez);
  objects.push(sphere);
}

function loadCylinder(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  const geometry = new THREE.CylinderGeometry( 0.2, 0.2, 0.5,10 );
  //  const geometry2 = new THREE.sp
  const material = new THREE.MeshLambertMaterial( { color: 0xc0c0c0 } );
  var mesh = new THREE.Mesh( geometry, material );
  console.log("cylinder scene"+currentScene);
  anchor[currentScene].group.add(mesh);
  mesh.position.set(posx*0.1,posz*0.1,posy*0.1);
      mesh.rotation.set(rotx,roty,rotz);
    mesh.scale.set(scalex,scaley,scalez);
  objects.push(mesh);
}

function loadCapsule(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  console.log("capsule scene "+currentScene);
  // Instantiate a loader
const loader = new GLTFLoader();


// Load a glTF resource
loader.load(
  // resource URL
  'models/capsule.glb',
  // called when the resource is loaded
  function ( gltf ) {

    
    //scene.add( gltf.scene );
    console.log("capsule scene "+gltfScene[gltfIndex]);
    anchor[gltfScene[gltfIndex]].group.add(gltf.scene);
    gltfIndex++;
    mesh= gltf.scene;
    gltf.scene.position.set(posx*0.1,posy*0.1,posz*0.1);
    gltf.scene.rotation.set(rotx,roty,rotz);
    gltf.scene.scale.set(scalex*0.1,scaley*0.1,scalez*0.1);

    gltf.animations; // Array<THREE.AnimationClip>
    gltf.scene; // THREE.Group
    gltf.scenes; // Array<THREE.Group>
    gltf.cameras; // Array<THREE.Camera>
    gltf.asset; // Object

      mixer = new THREE.AnimationMixer( gltf.scene );
        
        gltf.animations.forEach( ( clip ) => {
          
            mixer.clipAction( clip ).play();
          
        } );
    

  },
  // called while loading is progressing
  function ( xhr ) {

    console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

  },
  // called when loading has errors
  function ( error ) {

    console.log( 'An error happened' );

  }
  );
}

function loadPolyhedron(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  const geometry = new THREE.TetrahedronGeometry(0.2,0);
  const material = new THREE.MeshBasicMaterial( { color: 0xc0c0c0 } );
  var sphere = new THREE.Mesh( geometry, material );
  anchor[currentScene].group.add(sphere);
  sphere.position.set(posx*0.1,posz*0.1,posy*0.1);
      sphere.rotation.set(rotx,roty,rotz);
    sphere.scale.set(scalex,scaley,scalez);
  objects.push(sphere);
}

function loadGoldberg(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  const geometry = new THREE.DodecahedronGeometry(0.4,0);
  const material = new THREE.MeshBasicMaterial( { color: 0xc0c0c0 } );
  var sphere = new THREE.Mesh( geometry, material );
  anchor[currentScene].group.add(sphere);
  sphere.position.set(posx*0.1,posz*0.1,posy*0.1);
      sphere.rotation.set(rotx,roty,rotz);
    sphere.scale.set(scalex,scaley,scalez);
  objects.push(sphere);
}

function loadIcosphere(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  const geometry = new THREE.IcosahedronGeometry(0.2,0);
  const material = new THREE.MeshBasicMaterial( { color: 0xc0c0c0 } );
  var sphere = new THREE.Mesh( geometry, material );
  anchor[currentScene].group.add(sphere);
  sphere.position.set(posx*0.1,posz*0.1,posy*0.1);
        sphere.rotation.set(rotx,roty,rotz);
    sphere.scale.set(scalex,scaley,scalez);
  objects.push(sphere);
}

function loadTorus(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  const geometry = new THREE.TorusGeometry(0.2,0.02,10,10);
  const material = new THREE.MeshBasicMaterial( { color: 0xc0c0c0 } );
  var sphere = new THREE.Mesh( geometry, material );
  anchor[currentScene].group.add(sphere);
  sphere.position.set(posx*0.1,posz*0.1,posy*0.1);
      sphere.rotation.set(rotx,roty,rotz);
    sphere.scale.set(scalex,scaley,scalez);
  objects.push(sphere);
}

function loadTorusknot(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
  const geometry = new THREE.TorusKnotGeometry(0.1,0.01,5,5);
  const material = new THREE.MeshBasicMaterial( { color: 0xc0c0c0 } );
  var sphere = new THREE.Mesh( geometry, material );
  anchor[currentScene].group.add(sphere);
  sphere.position.set(posx*0.1,posz*0.1,posy*0.1);
      sphere.rotation.set(rotx,roty,rotz);
    sphere.scale.set(scalex,scaley,scalez);
  objects.push(sphere);
}

function loadImage(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez,url)
{
    var planeGeometry = new THREE.PlaneGeometry(0.3, 0.3, 1, 1);
    var textur = new THREE.TextureLoader().load( url );
    var planeMaterial = new THREE.MeshPhysicalMaterial( { map: textur } );
    var plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.receiveShadow = true;

    console.log("plane added");
    anchor[currentScene].group.add(plane);
    plane.position.set(posx*0.001,posz*0.001,posy*0.001);
        plane.rotation.set(rotx,roty,rotz);
    plane.scale.set(scalex,scaley,scalez);
  //  objects.push(plane);
}

function loadVideo(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez,url)
{
    var planeGeometry = new THREE.PlaneGeometry(0.3, 0.3, 1, 1);

    // Create a new VideoTexture from a video file
    video = document.createElement('video');
    video.src = url;
    video.load();
    video.pause();
  //  video.play();
    var videoTexture = new THREE.VideoTexture(video);

    // Create a new MeshPhysicalMaterial with the video texture as the map
    var planeMaterial = new THREE.MeshPhysicalMaterial( { map: videoTexture } );

    // Create a new Mesh object using the PlaneGeometry and MeshPhysicalMaterial
    var plane = new THREE.Mesh(planeGeometry, planeMaterial);

    plane.receiveShadow = true;

    console.log("plane added");
    anchor[currentScene].group.add(plane);
    plane.position.set(posx*0.001,posz*0.001,posy*0.001); 
        plane.rotation.set(rotx,roty,rotz);
    plane.scale.set(scalex,scaley,scalez);
    plane.name = "video";
    objects.push(plane);
    videos.set(plane, video);
}

function loadAudio(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez,url)
{
    var planeGeometry = new THREE.PlaneGeometry(0.1, 0.1, 1, 1);
    var textur = new THREE.TextureLoader().load( 'textures/audio.png' );
    var planeMaterial = new THREE.MeshPhysicalMaterial( { map: textur } );
    var plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.receiveShadow = true;

    audio = new Audio(url);

    console.log("plane added");
    anchor[currentScene].group.add(plane);
    plane.position.set(posx*0.001,posz*0.001,posy*0.001);
            plane.rotation.set(rotx,roty,rotz);
    plane.scale.set(scalex,scaley,scalez);
    plane.name = "audio";
    objects.push(plane);
    audios.set(plane, audio);
}

      

 // promisify font loading
 function loadFont(url) {
    const loader = new FontLoader()
    return new Promise((resolve, reject) => {
       loader.load(url, resolve, undefined, reject)
    })
 }
      
async function loadText(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez,label)
{
    const font = await loadFont('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json')

    console.log("label : "+label)
    const geometry = new TextGeometry(label, {
       font: font,
       size: 0.05,
       height: 0.01,
       curveSegments: 12,

    })
    const material = [
       new THREE.MeshPhongMaterial({
          color: 0xffcc22,
       flatShading: true
       }), // front
       new THREE.MeshPhongMaterial({
       color: 0xffcc22
       }) // side
    ]
    const mesh = new THREE.Mesh(geometry, material)
    mesh.position.set(posx*0.1,posz*0.1,posy*0.1);
    mesh.rotation.set(rotx,roty,rotz);
     mesh.scale.set(scalex,scaley,scalez);
    anchor[currentScene].group.add(mesh);
    objects.push(mesh);
    console.log("text added")
}

function loadButton(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez)
{
    //button same as cube
    const geometry = new THREE.BoxGeometry( 0.1, 0.05, 0.01 );
//  const geometry2 = new THREE.sp
    const material = new THREE.MeshLambertMaterial( { color: 0xc0c0c0 } );
    var mesh = new THREE.Mesh( geometry, material );

    anchor[currentScene].group.add(mesh);
    mesh.position.set(posx*0.1,posz*0.1,posy*0.1);
    mesh.rotation.set(rotx,roty,rotz);
    mesh.scale.set(scalex,scaley,scalez);
    objects.push(mesh);
}

function loadHotspot(hotspotData)
{
        console.log("load hotspot "+hotspotData);

        const geometry = new THREE.CylinderGeometry( 0.2, 0.2, 0.5,10 );
        //  const geometry2 = new THREE.sp

        var textur = new THREE.TextureLoader().load( hotspotData.mediaUrl );
        var planeMaterial = new THREE.MeshPhysicalMaterial( { map: textur } );

        const material = new THREE.MeshLambertMaterial( { color: 0xc0c0c0 } );

        var mesh = new THREE.Mesh( geometry, material );
        console.log("cylinder scene"+currentScene);
        anchor[currentScene].group.add(mesh);

        mesh.position.set(hotspotData.position.x*0.1,hotspotData.position.z*0.1,hotspotData.position.y*0.1);
     //   mesh.rotation.set(hotspotData.rotation.x,hotspotData.rotation.y,hotspotData.rotation.z);
     //   mesh.scale.set(hotspotData.scale.x,hotspotData.scale.y,hotspotData.scale.z);

        objects.push(mesh);
/*
        // Create 3D text
          
          const font = await loadFont('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json')

          console.log("label : "+label)
          const geometry = new TextGeometry(hotspotData.actionData.addHotspotQuestion.question, {
             font: font,
             size: 0.05,
             height: 0.01,
             curveSegments: 12,

          })
          const material = [
             new THREE.MeshPhongMaterial({
                color: 0xffcc22,
             flatShading: true
             }), // front
             new THREE.MeshPhongMaterial({
             color: 0xffcc22
             }) // side
          ]
          const mesh = new THREE.Mesh(geometry, material)

          plane.parent = parent;

          //add option
          console.log("options "+meshData.actionData.addHotspotQuestion.allOptions.length);

          meshData.actionData.addHotspotQuestion.allOptions.forEach((option, index) => {
            console.log(`Option ${index + 1}:`);
            console.log("Title:", option.title);
            console.log("Value:", option.value);

            // Create 3D text
            var text = option.title;
            var font = "36px Arial";
            var color = "white";
            var backgroundColor = "transparent";
            var textureText = new DynamicTexture("textTexture", 512, this.scene, true);
            textureText.hasAlpha = true;
            textureText.drawText(text, null, null, font, color, backgroundColor, true);

            // Create a plane to apply the texture
            var plane = MeshBuilder.CreatePlane("plane", { size: 2 }, this.scene);
            var material = new StandardMaterial("material", this.scene);
            material.diffuseTexture = textureText;
            plane.material = material;
            plane.position.y = hotspot.position.y+1-(index+1)*0.25;
            plane.parent = parent;

            //create option button
            var optionButton = MeshBuilder.CreateCylinder('cylinder', { height: 0.01, diameter: 0.15 }, this.scene);
          
            optionButton.rotation.x = -70* Math.PI / 180;
            optionButton.position.x = -1;
            optionButton.position.y = hotspot.position.y+1-(index+1)*0.25;
        
            console.log("rtotaion "+hotspot.rotation);
        
            var mat = new StandardMaterial("mat1", this.scene);
            var texture = new Texture("assets/uncheck.png", this.scene);
            mat.diffuseTexture = texture; 
        
            optionButton.material = mat;
            optionButton.parent = parent;
            this.optionState.set(optionButton,false);
            this.scene.onPointerObservable.add( (evt) => {
              if (evt.pickInfo?.pickedMesh === optionButton) {
               if(this.optionState.get(optionButton)==false)
               {
                this.optionState.set(optionButton,true);

                var texture = new Texture("assets/check.png", this.scene);
                mat.diffuseTexture = texture; 
        
                optionButton.material = mat;
               
               }else
               {
                this.optionState.set(optionButton,false);

                var texture = new Texture("assets/uncheck.png", this.scene);
                mat.diffuseTexture = texture; 
            
                optionButton.material = mat;
               }
                console.log("option clicked");
              }
            }, PointerEventTypes.POINTERPICK);

            if(index+1==meshData.actionData.addHotspotQuestion.allOptions.length)
            {
              var planeOpts = {
                height: 0.2, 
                width: 0.6,
                sideOrientation: Mesh.DOUBLESIDE
              };
              var Image = MeshBuilder.CreatePlane("plane", planeOpts, this.scene);

              var texture = new Texture("assets/submit.png", this.scene);
              var mat2 = new StandardMaterial("mat1", this.scene);
              mat2.diffuseTexture = texture; 
            
              Image.material = mat2;

              Image.position.x = 1;
              Image.position.y = hotspot.position.y+1-(index+2)*0.25; 

              this.scene.onPointerObservable.add( (evt) => {
                if (evt.pickInfo?.pickedMesh === Image) {
                 
                  console.log("submit clicked");
                   // Create 3D text
                  var text = meshData.actionData.addHotspotQuestion.feedbackIfIncorrect;
                  var font = "36px Arial";
                  var color = "white";
                  var backgroundColor = "transparent";
                  var textureText = new DynamicTexture("textTexture", 512, this.scene, true);
                  textureText.hasAlpha = true;
                  textureText.drawText(text, null, null, font, color, backgroundColor, true);

                  // Create a plane to apply the texture
                  var plane = MeshBuilder.CreatePlane("plane", { size: 2 }, this.scene);
                  var material = new StandardMaterial("material", this.scene);
                  material.diffuseTexture = textureText;
                  plane.material = material;
                  plane.position.y = hotspot.position.y+1;
                  plane.rotation.y = -90*Math.PI/180;

                  setTimeout(function() {
                    plane.visibility = 0; // Set visibility to 0 to hide the mesh
                  }, 5000);
                  
                  parent.setEnabled(false);
                }
              }, PointerEventTypes.POINTERPICK);

              Image.parent = parent;


            }
          });
*/
}

function loadGLTF(posx,posy,posz,rotx,roty,rotz,scalex,scaley,scalez,url)
{
  
    // Instantiate a loader
const loader = new GLTFLoader();


// Load a glTF resource
loader.load(
    // resource URL
    url,
    // called when the resource is loaded
    function ( gltf ) {

    
        //scene.add( gltf.scene );
    console.log("gltf scene"+gltfScene[gltfIndex]);
        anchor[gltfScene[gltfIndex]].group.add(gltf.scene);
        mesh= gltf.scene;
        gltf.scene.position.set(posx*0.1,posy*0.1,posz*0.1);
        gltf.scene.rotation.set(rotx,roty,rotz);
        gltf.scene.scale.set(scalex*0.1,scaley*0.1,scalez*0.1);

        gltf.animations; // Array<THREE.AnimationClip>
        gltf.scene; // THREE.Group
        gltf.scenes; // Array<THREE.Group>
        gltf.cameras; // Array<THREE.Camera>
        gltf.asset; // Object

      mixer = new THREE.AnimationMixer( gltf.scene );
        
        gltf.animations.forEach( ( clip ) => {
          
            mixer.clipAction( clip ).play();
          
        } );
    

    },
    // called while loading is progressing
    function ( xhr ) {

        console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

    },
    // called when loading has errors
    function ( error ) {

        console.log( 'An error happened' );

    }
    );
  }
        document.addEventListener( 'mousedown', onDocumentMouseDown );

            function onDocumentMouseDown( event ) {
                
            console.log("mouse down event");
            
            event.preventDefault();
            
            var mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
                                    0.5 );     
                                    
            var raycaster =  new THREE.Raycaster();    
            
                  raycaster.setFromCamera( mouse3D, camera );

            var intersects = raycaster.intersectObjects( scene.children ); 

            if ( intersects.length > 0 ) {

                console.log(" intersect len : "+intersects.length);
                
                console.log(" objects len : "+objects.length);
                
                for(var i=0;i<objects.length;i++)
                {  
                        if(intersects[0].object==objects[i])
                        {
                            console.log("object found "+objects[i].name);
                        if(objects[i].name == "video")
                        {
                           console.log("video clicked!");
                          if (videos.get(objects[i]).paused) {
                            videos.get(objects[i]).play();
                          } else {
                            videos.get(objects[i]).pause();
                          }
                        }
                        if(objects[i].name == "audio")
                        {
                           console.log("audio clicked!");
                          if (audios.get(objects[i]).paused) {
                            audios.get(objects[i]).play();
                          } else {
                            audios.get(objects[i]).pause();
                          }
                        }
                             if(recievedObjectCopy[i].actionObject=="NONE")
                             { 
                                console.log("none ");
                                //hide the mesh, replace below line
                                objects[i].position.set(0,0,0);
                             }
                             
                             if(recievedObjectCopy[i].actionObject=="CUBE")
                             {
                                 objects[i].position.set(10,0,0);
                                 loadBox(recievedObjectCopy[i].position.x,recievedObjectCopy[i].position.y,recievedObjectCopy[i].position.z);
                             }
                             
                             if(recievedObjectCopy[i].actionObject=="SPHERE")
                             {
                                 objects[i].position.set(10,0,0);
                                 loadSphere(recievedObjectCopy[i].position.x,recievedObjectCopy[i].position.y,recievedObjectCopy[i].position.z);
                             }
                             
                             if(recievedObjectCopy[i].actionObject=="IMAGE")
                             {
                                 objects[i].position.set(10,0,0);
                                 loadImage(recievedObjectCopy[i].position.x,recievedObjectCopy[i].position.y,recievedObjectCopy[i].position.z);
                             }
                        }
                }
                
            }
             
            }

    </script>
    <style>
      body {
    margin: 0;
      }
      #container {
    width: 100vw;
    height: 100vh;
    position: relative;
    overflow: hidden;
      }
      #control {
    position: fixed;
    top: 0;
    left: 0;
    z-index: 2;
      }
    </style>
  </head>
  <body>
    <div id="control">
      <button id="startButton">Start</button>
      <button id="stopButton">Stop</button>
    </div>
    <div id="container">
    </div>
  </body>
</html>
